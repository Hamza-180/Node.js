'use strict';

const CastError = require('../error/cast');
const EventEmitter = require('events').EventEmitter;
const ObjectExpectedError = require('../error/objectExpected');
const SchemaSubdocumentOptions = require('../options/schemaSubdocumentOptions');
const SchemaType = require('../schemaType');
const applyDefaults = require('../helpers/document/applyDefaults');
const $exists = require('./operators/exists');
const castToNumber = require('./operators/helpers').castToNumber;
const discriminator = require('../helpers/model/discriminator');
const geospatial = require('./operators/geospatial');
const getConstructor = require('../helpers/discriminator/getConstructor');
const handleIdOption = require('../helpers/schema/handleIdOption');
const internalToObjectOptions = require('../options').internalToObjectOptions;
const isExclusive = require('../helpers/projection/isExclusive');
const utils = require('../utils');
const InvalidSchemaOptionError = require('../error/invalidSchemaOption');

class SubdocumentType extends SchemaType {}

class SingleNested extends SubdocumentType {}

class SchemaSubdocument extends SchemaType {
  constructor(schema, path, options) {
    super(path, options, 'Embedded');

    if (schema.options.timeseries) {
      throw new InvalidSchemaOptionError(path, 'timeseries');
    }

    const schemaTypeIdOption = SchemaSubdocument.defaultOptions &&
      SchemaSubdocument.defaultOptions._id;

    if (schemaTypeIdOption != null) {
      options = options || {};
      options._id = schemaTypeIdOption;
    }

    schema = handleIdOption(schema, options);

    this.caster = _createConstructor(schema, null, options);
    this.caster.path = path;
    this.caster.prototype.$basePath = path;
    this.schema = schema;
    this.$isSingleNested = true;
    this.base = schema.base;
  }
}

function _createConstructor(schema, baseClass, options) {
  class SingleNested extends baseClass || SubdocumentType {
    constructor(value, path, parent) {
      super();

      this.$__parent = parent;
      SubdocumentType.apply(this, arguments);

      if (parent == null) {
        return;
      }
      this.$session(parent.$session());
    }
  }

  schema._preCompile();

  const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;
  Object.setPrototypeOf(SingleNested.prototype, proto);
  SingleNested.prototype.$__setSchema(schema);
  SingleNested.prototype.constructor = SingleNested;
  SingleNested.prototype.$__required = options?.required;
  SingleNested.base = schema.base;
  SingleNested.schema = schema;
  SingleNested.$isSingleNested = true;
  SingleNested.events = new EventEmitter();
  SingleNested.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };

  // apply methods
  for (const i in schema.methods) {
    SingleNested.prototype[i] = schema.methods[i];
  }

  // apply statics
  for (const i in schema.statics) {
    SingleNested[i] = schema.statics[i];
  }

  for (const i in EventEmitter.prototype) {
    SingleNested[i] = EventEmitter.prototype[i];
  }

  return SingleNested;
}

SchemaSubdocument.prototype.$conditionalHandlers.$geoWithin
