'use strict';

const SchemaType = require('../schemaType');
const MongooseError = require('../error/index');
const SchemaStringOptions = require('../options/schemaStringOptions');
const castString = require('../cast/string');
const utils = require('../utils');
const isBsonType = require('../helpers/isBsonType');

const CastError = SchemaType.CastError;

function SchemaString(key, options) {
  this.enumValues = [];
  this.regExp = null;
  SchemaType.call(this, key, options, 'String');
}

SchemaString.schemaName = 'String';
SchemaString.defaultOptions = {};

SchemaString.prototype = Object.create(SchemaType.prototype);
SchemaString.prototype.constructor = SchemaString;
Object.defineProperty(SchemaString.prototype, 'OptionsConstructor', {
  configurable: false,
  enumerable: false,
  writable: false,
  value: SchemaStringOptions
});

SchemaString._cast = castString;

SchemaString.cast = function cast(caster) {
  if (arguments.length === 0) {
    return this._cast;
  }
  if (caster === false) {
    caster = this._defaultCaster;
  }
  this._cast = caster;

  return this._cast;
};

SchemaString._defaultCaster = v => {
  if (v != null && typeof v !== 'string') {
    throw new Error();
  }
  return v;
};

SchemaString.get = SchemaType.get;

SchemaString.set = SchemaType.set;

SchemaString.setters = [];

SchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;

SchemaString.checkRequired = SchemaType.checkRequired;

SchemaString.prototype.enum = function() {
  if (this.enumValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.enumValidator;
    }, this);
    this.enumValidator = false;
  }

  if (arguments[0] === void 0 || arguments[0] === false) {
    return this;
  }

  let values;
  let errorMessage;

  if (utils.isObject(arguments[0])) {
    if (Array.isArray(arguments[0].values)) {
      values = arguments[0].values;
      errorMessage = arguments[0].message;
    } else {
      values = utils.object.vals(arguments[0]);
      errorMessage = MongooseError.messages.String.enum;
    }
  } else {
    values = arguments;
    errorMessage = MongooseError.messages.String.enum;
  }

  for (const value of values) {
    if (value !== undefined) {
      this.enumValues.push(this.cast(value));
    }
  }

  const vals = this.enumValues;
  this.enumValidator = function(v) {
    return null == v || ~vals.indexOf(v);
  };
  this.validators.push({
    validator: this.enumValidator,
    message: errorMessage,
    type: 'enum',
    enumValues: vals
  });

  return this;
};

SchemaString.prototype.lowercase = function(shouldApply) {
  if (arguments.length > 0 && !shouldApply) {
    return this;
  }
  return this.set(v => {
    if (typeof v !== 'string') {
      v = this.cast(v);
    }
    if (v) {
      return v.toLowerCase();
    }
    return v;
  });
};

SchemaString.prototype.uppercase = function(shouldApply) {
  if (arguments.length > 0 && !shouldApply) {
    return this;
  }
  return this.set(v => {
    if (typeof v !== 'string') {
      v = this.cast(v);
    }
    if (v) {
      return v.toUpperCase();
    }
    return v;
  });
};

SchemaString.prototype.trim = function(shouldTrim) {
  if (arguments.length > 0 && !shouldTrim) {
    return this;
  }
  return this.set(v => {
    if (typeof v !== 'string') {
      v = this.cast(v);
    }
    if (v) {
      return v.trim();
    }
    return v;
  });
};

SchemaString.prototype.minlength = function(value, message) {
  if (this.minlengthValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.minlengthValidator;
    }, this);
  }

  if (value !== null && value !== undefined) {
    let msg = message || MongooseError.messages.String.minlength;
    msg = msg.replace(/{MINLENGTH}/, value);
    this.validators.push({
      validator: this.minlengthValidator = function(v) {
        return v === null || v.length >= value;
      },
      message: msg,
      type: 'minlength',
      minlength: value
    });
  }

  return this;
};

SchemaString.prototype.minLength = SchemaString.prototype.minlength;

SchemaString.prototype.maxlength = function(value, message) {
  if (this.maxlengthValidator) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.maxlengthValidator;
    }, this);
  }

  if (value !== null && value !== undefined) {
    let msg = message || MongooseError.messages.String.maxlength;
    msg = msg.replace(/{MAXLENGTH}/, value);
    this.valid
