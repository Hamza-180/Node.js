'use strict';

const {
  MongooseError,
  CastError,
  ValidatorError,
} = require('./error/index');
const SchemaTypeOptions = require('./options/schemaTypeOptions');
const { $exists, $type } = require('./schema/operators');
const clone = require('./helpers/clone');
const handleImmutable = require('./helpers/schematype/handleImmutable');
const isAsyncFunction = require('./helpers/isAsyncFunction');
const isSimpleValidator = require('./helpers/isSimpleValidator');
const immediate = require('./helpers/immediate');
const schemaTypeSymbol = require('./helpers/symbols').schemaTypeSymbol;
const validatorErrorSymbol = require('./helpers/symbols').validatorErrorSymbol;
const documentIsModified = require('./helpers/symbols').documentIsModified;
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;

class SchemaType {
  constructor(path, options, instance) {
    this[schemaTypeSymbol] = true;
    this.path = path;
    this.instance = instance;
    this.validators = [];
    this.getters = this.constructor.hasOwnProperty('getters') ?
      this.constructor.getters.slice() :
      [];
    this.setters = this.constructor.hasOwnProperty('setters') ?
      this.constructor.setters.slice() :
      [];

    this.splitPath();

    options = options || {};
    const defaultOptions = this.constructor.defaultOptions || {};
    const defaultOptionsKeys = Object.keys(defaultOptions);

    for (const option of defaultOptionsKeys) {
      if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
        options[option] = defaultOptions[option];
      }
    }

    if (options.select == null) {
      delete options.select;
    }

    const Options = this.OptionsConstructor || SchemaTypeOptions;
    this.options = new Options(options);
    this._index = null;

    if (options.hasOwnProperty('immutable')) {
      this.$immutable = options.immutable;

      handleImmutable(this);
    }

    const keys = Object.keys(this.options);
    for (const prop of keys) {
      if (prop === 'cast') {
        if (Array.isArray(this.options[prop])) {
          this.castFunction.apply(this, this.options[prop]);
        } else {
          this.castFunction(this.options[prop]);
        }
        continue;
      }
      if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === 'function') {
        if (prop === 'index' && this._index) {
          if (options.index === false) {
            const index = this._index;
            if (typeof index === 'object' && index != null) {
              if (index.unique) {
                throw new Error('Path "' + this.path + '" may not have `index` ' +
                  'set to false and `unique` set to true');
              }
              if (index.sparse) {
                throw new Error('Path "' + this.path + '" may not have `index` ' +
                  'set to false and `sparse` set to true');
              }
            }

            this._index = false;
          }
          continue;
        }

        const val = options[prop];
        const opts = Array.isArray(val) ? val : [val];

        this[prop].apply(this, opts);
      }
    }

    Object.defineProperty(this, '$$context', {
      enumerable: false,
      configurable: false,
      writable: true,
      value: null,
    });
  }

  // ... rest of the code ...
}

module.exports = {
  SchemaType,
  CastError,
  ValidatorError,
};
