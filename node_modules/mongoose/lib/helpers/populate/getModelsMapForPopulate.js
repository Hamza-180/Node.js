'use strict';

const MongooseError = require('../../error/index');
const SkipPopulateValue = require('./skipPopulateValue');
const clone = require('../clone');
const get = require('../get');
const getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');
const getConstructorName = require('../getConstructorName');
const getSchemaTypes = require('./getSchemaTypes');
const getVirtual = require('./getVirtual');
const lookupLocalFields = require('./lookupLocalFields');
const mpath = require('mpath');
const modelNamesFromRefPath = require('./modelNamesFromRefPath');
const utils = require('../../utils');

const modelSymbol = require('../symbols').modelSymbol;
const populateModelSymbol = require('../symbols').populateModelSymbol;
const schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;
const StrictPopulate = require('../../error/strictPopulate');

module.exports = function getModelsMapForPopulate(model, docs, options) {
  const modelSchema = model.schema;
  const modelNameFromQuery = options.model && options.model.modelName || options.model;
  const map = [];
  const available = {};

  for (const doc of docs) {
    const data = getPopulateData(model, doc, options);
    if (data) {
      addModelNamesToMap(model, map, available, data.modelNames, options, data.data, doc);
    }
  }

  return map;
}

function getPopulateData(model, doc, options) {
  const schema = getSchemaTypes(model, doc.$__schema || modelSchema, doc);

  if (!schema) {
    return null;
  }

  const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;
  if (isUnderneathDocArray && get(options, 'options.sort') != null) {
    throw new MongooseError('Cannot populate with `sort` on path ' + options.path +
      ' because it is a subproperty of a document array');
  }

  const virtual = getVirtual(model.schema, options.path);
  if (virtual) {
    return _virtualPopulate(model, doc, options, virtual);
  }

  const ref = schema.options.ref;
  const refPath = schema.options.refPath;
  if (ref || refPath) {
    return _getModelNames(model, schema, modelNameFromQuery, model, ref, refPath);
  }

  if (schema.$isMongooseDocumentArray && !schema.options.ref && !schema.options.refPath) {
    return null;
  }

  if (schema.instance === 'Embedded' && schema.options.ref) {
    return _getModelNames(model, schema, modelNameFromQuery, model, schema.options.ref);
  }

  return null;
}

function _getModelNames(model, schema, modelNameFromQuery, modelToCompare, ref, refPath) {
  let modelNames;
  let isRefPath = false;

  if (refPath) {
    modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);
    isRefPath = true;
  } else if (ref) {
    modelNames = [ref];
  } else if (modelNameFromQuery) {
    modelNames = [modelNameFromQuery];
  } else {
    return null;
  }

  const justOne = !schema.$isMongooseArray && !schema._arrayPath;

  return { modelNames, justOne, isRefPath, refPath };
}

function _virtualPopulate(model, doc, options, virtual) {
  const data = {};
  const localField = getLocalField(virtual, options);
  const foreignField = getForeignField(virtual, options);

  if (!localField || !foreignField) {
    throw new MongooseError(`Cannot populate virtual \`${options.path}\` on model \`${model.modelName}\`, because options \`localField\` and / or \`foreignField\` are missing`);
  }

  data.count = virtual.options.count;
  data.isRefPath = false;
  data.justOne = virtual.options.justOne;
  data.virtual = virtual;

  const ret = _getLocalFieldValues(doc, localField, model, options, virtual);

  return { modelNames: [virtual.options.ref], data };
}

function getLocalField(virtual, options) {
  if (typeof options.localField === 'string') {
    return options.localField;
  }

  if (typeof virtual.options.localField === 'function') {
    return virtual.options.localField.call(doc, doc);
  }

  if (Array.isArray(virtual.options.localField)) {
    return virtual.options.localField.map(field => field);
  }

  return virtual.options.localField;
}

function getForeignField(virtual, options) {
  if (typeof options.foreignField === 'string') {
    return options.foreignField;
  }

  if (typeof virtual.options.foreignField === 'function') {
    return virtual.options.foreignField.call(doc, doc);
  }

  return virtual.options.foreignField;
}

function addModelNamesToMap(model, map, available, modelNames, options, data, doc) {
  if (!modelNames) {
    return;
  }

  for (const modelName of modelNames) {
    const Model = getModelByName(model, modelName);

    if (!Model) {
      continue;
    }

    const ids = getIds(data, modelName);

    const perDocumentLimit = options.perDocumentLimit == null ?
      get(options, 'options.perDocumentLimit', null)
