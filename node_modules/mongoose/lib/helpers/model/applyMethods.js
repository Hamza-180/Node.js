'use strict';

const get = require('../get');
const utils = require('../../utils');

/**
 * Register methods for a model
 *
 * @param {Model} model
 * @param {Schema} schema
 * @api private
 */
module.exports = function applyMethods(model, schema) {
  function apply(method) {
    if (!schema.methods.hasOwnProperty(method)) {
      return;
    }

    const methodKeys = Object.keys(schema.methods[method]);
    if (methodKeys.length === 0) {
      delete schema.methods[method];
      return;
    }

    const h = {};
    for (const k of methodKeys) {
      h[k] = schema.methods[method][k].bind(this);
    }

    Object.defineProperty(model.prototype, method, {
      get: function() {
        return h;
      },
      configurable: true
    });
  }

  for (const method of Object.keys(schema.methods)) {
    const fn = schema.methods[method];

    if (schema.tree.hasOwnProperty(method)) {
      throw new Error(`You have a method and a property in your schema both named "${method}".`);
    }

    if (typeof fn === 'function' && model.prototype[method] === fn) {
      delete schema.methods[method];
      continue;
    }

    if (schema.reserved.hasOwnProperty(method)) {
      if (!get(schema, `methodOptions.${method}.suppressWarning`, false)) {
        utils.warn(`mongoose: the method name "${method}" is used by mongoose internally, overwriting it may cause bugs. If you're sure you know what you're doing, you can suppress this error by using \`schema.method('${method}', fn, { suppressWarning: true })\`.`);
      }
    }

    if (typeof fn === 'function') {
      model.prototype[method] = fn;
    } else {
      apply(method);
    }
  }

  // Recursively call `applyMethods()` on child schemas
  model.$appliedMethods = true;
  for (const key of Object.keys(schema.paths)) {
    const type = schema.paths[key];
    if (type.$isSingleNested && !type.caster.$appliedMethods) {
      applyMethods(type.caster, type.schema);
    }
    if (type.constructor.$isMongooseDocumentArray && !type.constructor.$appliedMethods) {
      applyMethods(type.constructor, type.schema);
    }
  }

  // Validate that there are no remaining methods
  if (Object.keys(schema.methods).length > 0) {
    throw new Error('There are still methods left in the schema after applying them.');
  }
};
