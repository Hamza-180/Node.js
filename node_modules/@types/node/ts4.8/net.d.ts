/**
 * The `net` module provides an asynchronous network API for creating stream-based
 * TCP or `IPC` servers and clients.
 *
 * It can be accessed using:
 *
 * ```js
 * import net from 'node:net';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/net.js)
 */

import * as stream from "node:stream";
import { Abortable, EventEmitter } from "node:events";
import * as dns from "node:dns";

type LookupFunction = (
  hostname: string,
  options: dns.LookupAllOptions,
  callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void,
) => void;

interface AddressInfo {
  address: string;
  family: string;
  port: number;
}

interface SocketConstructorOpts {
  fd?: number | undefined;
  allowHalfOpen?: boolean | undefined;
  readable?: boolean | undefined;
  writable?: boolean | undefined;
  signal?: AbortSignal;
}

interface OnReadOpts {
  buffer: Uint8Array | (() => Uint8Array);
  callback(bytesWritten: number, buf: Uint8Array): boolean;
}

interface ConnectOpts {
  onread?: OnReadOpts | undefined;
}

interface TcpSocketConnectOpts extends ConnectOpts {
  port: number;
  host?: string | undefined;
  localAddress?: string | undefined;
  localPort?: number | undefined;
  hints?: number | undefined;
  family?: number | undefined;
  lookup?: LookupFunction | undefined;
  noDelay?: boolean | undefined;
  keepAlive?: boolean | undefined;
  keepAliveInitialDelay?: number | undefined;
  autoSelectFamily?: boolean | undefined;
  autoSelectFamilyAttemptTimeout?: number | undefined;
}

interface IpcSocketConnectOpts extends ConnectOpts {
  path: string;
}

type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;

type SocketReadyState = "opening" | "open" | "readOnly" | "writeOnly" | "closed";

class Socket extends stream.Duplex {
  constructor(options?: SocketConstructorOpts);

  destroySoon(): void;

  write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;
  write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;

  connect(options: SocketConnectOpts, connectionListener?: () => void): this;
  connect(port: number, host: string, connectionListener?: () => void): this;
  connect(port: number, connectionListener?: () => void): this;
  connect(path: string, connectionListener?: () => void): this;

  setEncoding(encoding?: BufferEncoding): this;

  pause(): this;
  resetAndDestroy(): this;
  resume(): this;

  setTimeout(timeout: number, callback?: () => void): this;
  setNoDelay(noDelay?: boolean): this;
  setKeepAlive(enable?: boolean, initialDelay?: number): this;

  address(): AddressInfo | {};
  unref(): this;
  ref(): this;

  get autoSelectFamilyAttemptedAddresses(): string[];
  get bufferSize(): number;
  get bytesRead(): number;
  get bytesWritten(): number;
  get connecting(): boolean;
  get pending(): boolean;
  get destroyed(): boolean;
  get localAddress(): string | undefined;
  get localPort(): number | undefined;
  get localFamily(): string | undefined;
  get readyState(): SocketReadyState;
  get remoteAddress(): string | undefined;
  get remoteFamily(): string | undefined;
  get remotePort(): number | undefined;
  get timeout(): number | undefined;

  end(callback?: () => void): this;
  end(buffer: Uint8Array | string, callback?: () => void): this;
  end(str: Uint8Array | string, encoding?: BufferEncoding, callback?: () => void): this;

  addListener(event: string, listener: (...args: any[]) => void): this;
  addListener(event: "close", listener: (hadError: boolean) => void): this;
  addListener(event: "connect", listener: () => void): this;
  addListener(event: "data", listener: (data: Buffer) => void): this;
  addListener(event: "drain", listener: () => void): this;
  addListener(event: "end", listener: () => void): this;
  addListener(event: "error", listener: (err: Error) => void): this;
  addListener(
    event: "lookup",
    listener: (err: Error, address: string, family: string | number, host: string) => void,
  ): this;
  addListener(event: "ready", listener: () => void): this;
  addListener(event: "timeout", listener: () => void): this;

  emit(event: string | symbol, ...args: any[]): boolean;
  emit(event: "close", hadError: boolean): boolean;
  emit(event: "connect"): boolean;
  emit(event: "data", data: Buffer): boolean;
  emit(event: "drain"): boolean;
  emit(event: "end"): boolean;
  emit(event: "error", err: Error): boolean;
  emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;
  emit(event: "ready"): boolean;
  emit(event: "timeout"): boolean;

  on(event: string, listener: (...args: any[]) => void): this;
  on(event: "close", listener: (hadError: boolean) => void): this;
  on(event: "connect", listener: () => void): this;
  on(event: "data", listener: (data: Buffer) => void): this;
  on(event: "drain", listener: () => void): this;
 
