"use strict";
const { Buffer } = require("buffer");
const { StringDecoder } = require("string_decoder");

// Export Node.js internal encodings.
module.exports = {
  // Encodings
  utf8: { type: "_internal", bomAware: true },
  cesu8: { type: "_internal", bomAware: true },
  unicode11utf8: "utf8",

  ucs2: { type: "_internal", bomAware: true },
  utf16le: "ucs2",

  binary: { type: "_internal" },
  base64: { type: "_internal" },
  hex: { type: "_internal" },

  // Codec.
  _internal: InternalCodec,
};

//------------------------------------------------------------------------------

class InternalCodec {
  constructor(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    this.encoder = this.getEncoder(this.enc);
    this.decoder = this.getDecoder(this.enc);
  }

  getEncoder(enc) {
    if (enc === "base64") return InternalEncoderBase64;
    if (enc === "cesu8") {
      enc = "utf8"; // Use utf8 for decoding.
      return InternalEncoderCesu8;
    }
    return InternalEncoder;
  }

  getDecoder(enc) {
    if (enc === "cesu8") return InternalDecoderCesu8;
    return StringDecoder;
  }
}

//------------------------------------------------------------------------------

class InternalEncoder {
  constructor(options, codec) {
    this.enc = codec.enc;
  }

  write(str) {
    if (!str) return Buffer.alloc(0);
    return Buffer.from(str, this.enc);
  }

  end() {}
}

//------------------------------------------------------------------------------

class InternalEncoderBase64 extends InternalEncoder {
  constructor(options, codec) {
    super(options, codec);
    this.prevStr = "";
  }

  write(str) {
    str = this.prevStr + str;
    const completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return super.write(str);
  }
}

//------------------------------------------------------------------------------

class InternalEncoderCesu8 extends InternalEncoder {
  constructor(options, codec) {
    super(options, codec);
  }

  write(str) {
    const buf = Buffer.alloc(str.length * 3);
    let bufIdx = 0;

    for (let i = 0; i < str.length; i++) {
      const charCode = str.charCodeAt(i);

      if (charCode < 0x80) {
        buf[bufIdx++] = charCode;
      } else if (charCode < 0x800) {
        buf[bufIdx++] = (charCode >>> 6) & 0x1F | 0xC0;
        buf[bufIdx++] = charCode & 0x3F | 0x80;
      } else {
        buf[bufIdx++] = (charCode >>> 12) & 0x0F | 0xE0;
        buf[bufIdx++] = ((charCode >>> 6) & 0x3F) | 0x80;
        buf[bufIdx++] = charCode & 0x3F | 0x80;
      }
    }

    return buf.slice(0, bufIdx);
  }
}

//------------------------------------------------------------------------------

class InternalDecoderCesu8 {
  constructor(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }

  write(buf) {
    let acc = this.acc;
    let contBytes = this.contBytes;
    let accBytes = this.accBytes;
    let res = "";

    for (let i = 0; i < buf.length; i++) {
      const curByte = buf[i];

      if ((curByte & 0xC0) !== 0x80) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }

        if (curByte < 0x80) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 0xE0) {
          acc = curByte & 0x1F;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 0xF0) {
          acc = curByte & 0x0F;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = (acc << 6) | (curByte & 0x3f);
          contBytes--;
          accBytes++;

          if (contBytes === 0) {
            if (accBytes === 2 && acc < 0x80 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 0x800)
              res += this.defaultCharUnicode;
            else res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }

    this.acc =
