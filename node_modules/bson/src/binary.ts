import {
  type InspectFn,
  defaultInspect,
  isAnyArrayBuffer,
  isUint8Array
} from './parser/utils';
import { BSONError } from './error';
import { BSON_BINARY_SUBTYPE_UUID_NEW } from './constants';
import { ByteUtils } from './utils/byte_utils';
import { BSONValue } from './bson_value';

/** @public */
export type BinarySequence = Uint8Array | number[];

/** @public */
export interface BinaryExtendedLegacy {
  $type: string;
  $binary: string;
}

/** @public */
export interface BinaryExtended {
  $binary: {
    subType: string;
    base64: string;
  };
}

/**
 * A class representation of the BSON Binary type.
 * @public
 * @category BSONType
 */
export class Binary extends BSONValue {
  get _bsontype(): 'Binary' {
    return 'Binary';
  }

  /** Initial buffer default size */
  static readonly BUFFER_SIZE = 256;
  /** Default BSON type */
  static readonly SUBTYPE_DEFAULT = 0;
  /** Function BSON type */
  static readonly SUBTYPE_FUNCTION = 1;
  /** Byte Array BSON type */
  static readonly SUBTYPE_BYTE_ARRAY = 2;
  /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */
  static readonly SUBTYPE_UUID_OLD = 3;
  /** UUID BSON type */
  static readonly SUBTYPE_UUID = 4;
  /** MD5 BSON type */
  static readonly SUBTYPE_MD5 = 5;
  /** Encrypted BSON type */
  static readonly SUBTYPE_ENCRYPTED = 6;
  /** Column BSON type */
  static readonly SUBTYPE_COLUMN = 7;
  /** User BSON type */
  static readonly SUBTYPE_USER_DEFINED = 128;

  buffer!: Uint8Array;
  sub_type!: number;
  position!: number;

  /**
   * Create a new Binary instance.
   * @param buffer - a buffer object containing the binary data.
   * @param subType - the option binary type.
   */
  constructor(buffer?: BinarySequence, subType?: number) {
    super();
    if (
      buffer !== undefined &&
      typeof buffer !== 'string' &&
      !ArrayBuffer.isView(buffer) &&
      !isAnyArrayBuffer(buffer) &&
      !Array.isArray(buffer)
    ) {
      throw new BSONError('Binary can only be constructed from Uint8Array or number[]');
    }

    this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;

    if (buffer === undefined) {
      // create an empty binary buffer
      this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
      this.position = 0;
    } else {
      this.buffer = Array.isArray(buffer)
        ? ByteUtils.fromNumberArray(buffer)
        : ByteUtils.toLocalBufferType(buffer);
      this.position = this.buffer.byteLength;
    }
  }

  // ... rest of the class methods

  /**
   * Returns the underlying buffer of this Binary instance.
   */
  toBuffer(): Uint8Array {
    return this.buffer.slice(0, this.position);
  }

  /**
   * Creates a new Binary instance from the given buffer.
   * @param buffer - the buffer to create the instance from.
   * @param subType - the subtype of the new instance.
   */
  static fromBuffer(buffer: Uint8Array, subType?: number): Binary {
    const binary = new Binary();
    binary.buffer = buffer;
    binary.sub_type = subType ?? Binary.SUBTYPE_DEFAULT;
    binary.position = buffer.byteLength;
    return binary;
  }

  // ... rest of the class methods
}

/**
 * A class representation of the BSON UUID type.
 * @public
 */
export class UUID extends Binary {
  // ... rest of the class methods

  /**
   * Returns the underlying buffer of this UUID instance.
   */
  toBuffer(): Uint8Array {
    return this.buffer.slice(0, 16);
  }

  /**
   * Creates a new UUID instance from the given buffer.
   * @param buffer - the buffer to create the instance from.
   * @param subType - the subtype of the new instance.
   */
  static fromBuffer(buffer: Uint8Array, subType?: number): UUID {
    const uuid = new UUID();
    uuid.buffer = buffer;
    uuid.sub_type = subType ?? Binary.SUBTYPE_UUID;
    uuid.position = buffer.byteLength;
    return uuid;
  }

  // ... rest of the class methods
}
