import { 
  MongoClient, 
  ServerApiVersion, 
  Db, 
  MongoNamespace, 
  ReadPreference, 
  ReadConcern, 
  WriteConcern, 
  ServerAddress, 
  Server, 
  MongoParseError, 
  MongoAPIError, 
  MongoInvalidArgumentError, 
  MongoMissingCredentialsError, 
  MongoConnectionError, 
  MongoServerSelectionError, 
  MongoNetworkError, 
  MongoCommandError, 
  MongoTimeoutError, 
  MongoTopologyWasDestroyedError, 
  MongoCursorNotFoundError, 
  MongoDocumentNotFoundError, 
  MongoWriteConcernError, 
  MongoUserNotFoundError, 
  MongoServerError
} from 'mongodb';
import { 
  parseInteger, 
  isRecord, 
  matchesParentDomain, 
  HostAddress, 
  URLSearchParams, 
  MongoConnectionStringURL, 
  MongoCredentials, 
  AuthMechanism, 
  AuthMechanismProperties, 
  AuthProvider, 
  AWSAuthProvider, 
  GSSAPIAuthProvider, 
  OIDCAuthProvider, 
  X509AuthProvider, 
  MONGODB_AWS, 
  MONGODB_DEFAULT, 
  MONGODB_GSSAPI, 
  MONGODB_OIDC, 
  MONGODB_X509, 
  AuthMechanismPropertiesMap, 
  AuthMechanismPropertiesRecord, 
  AuthMechanismPropertiesArray, 
  AuthMechanismPropertiesString, 
  AuthMechanismPropertiesBoolean, 
  AuthMechanismPropertiesNumber, 
  AuthMechanismPropertiesUndefined, 
  AuthMechanismPropertiesNull, 
  AuthMechanismPropertiesSymbol, 
  AuthMechanismPropertiesObject, 
  AuthMechanismPropertiesFunction, 
  AuthMechanismPropertiesBigInt, 
  AuthMechanismPropertiesDate, 
  AuthMechanismPropertiesBuffer, 
  AuthMechanismPropertiesMap as AuthMechanismPropertiesInternalMap, 
  AuthMechanismPropertiesArray as AuthMechanismPropertiesInternalArray, 
  AuthMechanismPropertiesRecord as AuthMechanismPropertiesInternalRecord, 
  AuthMechanismPropertiesString as AuthMechanismPropertiesInternalString, 
  AuthMechanismPropertiesBoolean as AuthMechanismPropertiesInternalBoolean, 
  AuthMechanismPropertiesNumber as AuthMechanismPropertiesInternalNumber, 
  AuthMechanismPropertiesUndefined as AuthMechanismPropertiesInternalUndefined, 
  AuthMechanismPropertiesNull as AuthMechanismPropertiesInternalNull, 
  AuthMechanismPropertiesSymbol as AuthMechanismPropertiesInternalSymbol, 
  AuthMechanismPropertiesObject as AuthMechanismPropertiesInternalObject, 
  AuthMechanismPropertiesFunction as AuthMechanismPropertiesInternalFunction, 
  AuthMechanismPropertiesBigInt as AuthMechanismPropertiesInternalBigInt, 
  AuthMechanismPropertiesDate as AuthMechanismPropertiesInternalDate, 
  AuthMechanismPropertiesBuffer as AuthMechanismPropertiesInternalBuffer
} from 'mongodb-connection-string-url';
import { 
  URL, 
  URLSearchParams as URLSearchParamsPolyfill
} from 'url';
import { 
  deprecate, 
  deprecateLegacyUriOption
} from './utils';

const VALID_TXT_RECORDS = ['authSource', 'replicaSet', 'loadBalanced'];
const LB_SINGLE_HOST_ERROR = 'loadBalanced option only supported with a single host in the URI';
const LB_REPLICA_SET_ERROR = 'loadBalanced option not supported with a replicaSet option';
const LB_DIRECT_CONNECTION_ERROR = 'loadBalanced option not supported when directConnection is provided';

async function resolveSRVRecord(options: { srvHost: string, srvServiceName?: string }): Promise<ServerAddress[]> {
  if (typeof options.srvHost !== 'string') {
    throw new MongoAPIError('Option "srvHost" must not be empty');
  }
  if (options.srvHost.split('.').length < 3) {
    throw new MongoAPIError('URI must include hostname, domain name, and tld');
  }
  const lookupAddress = options.srvHost;
  const addresses = await dns.promises.resolveSrv(`_${options.srvServiceName || 'mongodb'}._tcp.${lookupAddress}`);
  if (addresses.length === 0) {
    throw new MongoAPIError('No addresses found at host');
  }
  for (const { name } of addresses) {
    if (!matchesParentDomain(name, lookupAddress)) {
      throw new MongoAPIError('Server record does not share hostname with parent URI');
    }
  }
  const hostAddresses = addresses.map(r => HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
  validateLoadBalancedOptions(hostAddresses, options, true);
  let record;
  try {
    record = await dns.promises.resolveTxt(lookupAddress);
  }
  catch (error) {
    if (error.code !== 'ENODATA' && error.code !== 'ENOTFOUND') {
      throw error;
    }
    return hostAddresses;
  }
  if (record.length > 1) {
    throw new MongoParseError('Multiple text records not allowed');
  }
  const txtRecordOptions = new URLSearchParams(record[0].join(''));
  const txtRecordOptionKeys = [...txtRecordOptions.keys()];
  if (txtRecordOptionKeys.some(
