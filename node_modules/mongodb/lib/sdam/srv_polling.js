"use strict";
import { defineProperty, ObjectDefineProperty } from "typescript";
import { MongoRuntimeError } from "../error";
import { HostAddress, TypedEventEmitter } from "../mongo_types";
import { resolveSrv, SrvRecord } from "dns";
import { setTimeout, clearTimeout } from "timers";
import { matchesParentDomain } from "../utils";
/**
 * @internal
 * @category Event
 */
class SrvPollingEvent {
    constructor(srvRecords: SrvRecord[]) {
        this.srvRecords = srvRecords;
    }
    hostnames(): Set<string> {
        return new Set(this.srvRecords.map(r => HostAddress.fromSrvRecord(r).toString()));
    }
}
ObjectDefineProperty(exports, "SrvPollingEvent", { value: SrvPollingEvent });
/** @internal */
class SrvPoller extends TypedEventEmitter {
    private srvHost: string;
    private srvMaxHosts: number;
    private srvServiceName: string;
    private rescanSrvIntervalMS: number;
    private heartbeatFrequencyMS: number;
    private haMode: boolean;
    private generation: number;
    private _timeout: NodeJS.Timeout | undefined;
    constructor(options: {
        srvHost: string;
        srvMaxHosts?: number;
        srvServiceName?: string;
        rescanSrvIntervalMS?: number;
        heartbeatFrequencyMS?: number;
    }) {
        super();
        if (!options.srvHost) {
            throw new MongoRuntimeError('Options for SrvPoller must exist and include srvHost');
        }
        this.srvHost = options.srvHost;
        this.srvMaxHosts = options.srvMaxHosts ?? 0;
        this.srvServiceName = options.srvServiceName ?? 'mongodb';
        this.rescanSrvIntervalMS = options.rescanSrvIntervalMS ?? 60000;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 10000;
        this.haMode = false;
        this.generation = 0;
        this._timeout = undefined;
    }
    get srvAddress(): string {
        return `_${this.srvServiceName}._tcp.${this.srvHost}`;
    }
    get intervalMS(): number {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start(): void {
        if (!this._timeout) {
            this.schedule();
        }
    }
    stop(): void {
        if (this._timeout) {
            clearTimeout(this._timeout);
            this.generation += 1;
            this._timeout = undefined;
        }
    }
    // TODO(NODE-4994): implement new logging logic for SrvPoller failures
    schedule(): void {
        if (this._timeout) {
            clearTimeout(this._timeout);
        }
        this._timeout = setTimeout(() => {
            this._poll().catch(() => null);
        }, this.intervalMS);
    }
    success(srvRecords: SrvRecord[]): void {
        this.haMode = false;
        this.schedule();
        this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
    failure(): void {
        this.haMode = true;
        this.schedule();
    }
    async _poll(): Promise<void> {
        const generation = this.generation;
        let srvRecords: SrvRecord[];
        try {
            srvRecords = await resolveSrv(this.srvAddress);
        } catch (dnsError) {
            this.failure();
            return;
        }
        if (generation !== this.generation) {
            return;
        }
        const finalAddresses: SrvRecord[] = [];
        for (const record of srvRecords) {
            if (matchesParentDomain(record.name, this.srvHost)) {
                finalAddresses.push(record);
            }
        }
        if (!finalAddresses.length) {
            this.failure();
            return;
        }
        this.success(finalAddresses);
    }
}
ObjectDefineProperty(exports, "SrvPoller", { value: SrvPoller });
ObjectDefineProperty(exports, "SRV_RECORD_DISCOVERY", {
    value: "srvRecordDiscovery",
    writable: false,
});
//# sourceMappingURL=srv_polling.js.map
