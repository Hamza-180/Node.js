import { ReadPreference, isReadPreference } from '../read_preference';
import { BSON, resolveBSONOptions } from '../bson';

export const Aspect = {
  READ_OPERATION: Symbol('READ_OPERATION'),
  WRITE_OPERATION: Symbol('WRITE_OPERATION'),
  RETRYABLE: Symbol('RETRYABLE'),
  EXPLAINABLE: Symbol('EXPLAINABLE'),
  SKIP_COLLATION: Symbol('SKIP_COLLATION'),
  CURSOR_CREATING: Symbol('CURSOR_CREATING'),
  MUST_SELECT_SAME_SERVER: Symbol('MUST_SELECT_SAME_SERVER')
};

const kSession = Symbol('session');

/**
 * This class acts as a parent class for any operation and is responsible for setting this.options,
 * as well as setting and getting a session.
 * Additionally, this class implements `hasAspect`, which determines whether an operation has
 * a specific aspect.
 * @internal
 */
export class AbstractOperation {
  private readonly aspects: Map<symbol, boolean>;

  constructor(options: any = {}) {
    this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION)
      ? ReadPreference.primary
      : isReadPreference(options.readPreference)
        ? options.readPreference
        : ReadPreference.fromOptions(options) ?? ReadPreference.primary;

    this.bsonOptions = resolveBSONOptions(options);
    this[kSession] = options.session != null ? options.session : undefined;
    this.options = options;
    this.bypassPinningCheck = !!options.bypassPinningCheck;
    this.trySecondaryWrite = false;

    this.aspects = defineAspects(this, options.aspects);
  }

  private defineAspects(operation: AbstractOperation, aspects: any) {
    if (!Array.isArray(aspects) && !(aspects instanceof Map)) {
      aspects = [aspects];
    }
    aspects = new Map(aspects.map((aspect: any) => [aspect, true]));
    Object.defineProperty(operation, 'aspects', {
      value: aspects,
      writable: false
    });
    return aspects;
  }

  hasAspect(aspect: symbol) {
    return this.aspects.has(aspect);
  }

  get session() {
    return this[kSession];
  }

  clearSession() {
    this[kSession] = undefined;
  }

  get canRetryRead() {
    return true;
  }

  get canRetryWrite() {
    return true;
  }
}

//# sourceMappingURL=operation.js.map
