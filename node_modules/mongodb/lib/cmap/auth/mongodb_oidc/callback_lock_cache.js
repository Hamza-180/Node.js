// src/callbackLockCache.ts

import type { Connection } from '../../../connection';
import type { Credentials } from '../../../credentials';
import { MongoInvalidArgumentError } from '../../../error';
import { Cache } from './cache';
import { hash } from './hash';

/** Error message for when request callback is missing. */
const REQUEST_CALLBACK_REQUIRED_ERROR = 'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.';

/** Counter for function "hashes".*/
let FN_HASH_COUNTER = 0;

/** No function present function */
const NO_FUNCTION = async () => ({ accessToken: 'test' });

/** The map of function hashes */
const FN_HASHES = new WeakMap<Function, number>();

/**
 * A cache of request and refresh callbacks per server/user.
 */
export class CallbackLockCache extends Cache {
  /**
   * Get the callbacks for the connection and credentials. If an entry does not
   * exist a new one will get set.
   */
  getEntry(connection: Connection, credentials: Credentials) {
    const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
    const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;
    if (!requestCallback) {
      throw new MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);
    }
    const functionHash = hash.hashFunctions(requestCallback, refreshCallback);
    const key = this.cacheKey(connection.address, credentials.username, functionHash);
    const entry = this.entries.get(key);
    if (entry) {
      return entry;
    }
    return this.addEntry(key, functionHash, requestCallback, refreshCallback);
  }

  /**
   * Set locked callbacks on for connection and credentials.
   */
  addEntry(key: string, functionHash: string, requestCallback: Function, refreshCallback?: Function) {
    const entry = {
      requestCallback: withLock(requestCallback),
      refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,
      functionHash: functionHash
    };
    this.entries.set(key, entry);
    return entry;
  }

  /**
   * Create a cache key from the address and username.
   */
  cacheKey(address: string, username: string, functionHash: string) {
    return this.hashedCacheKey(address, username, functionHash);
  }
}

/**
 * Ensure the callback is only executed one at a time.
 */
function withLock(callback: Function) {
  let lock = Promise.resolve();
  return async (info: any, context: any) => {
    await lock;
    lock = lock.then(() => callback(info, context));
    return lock;
  };
}

// src/hash.ts

/**
 * Get the hash string for the request and refresh functions.
 */
export function hashFunctions(requestFn: Function, refreshFn?: Function) {
  let requestHash = FN_HASHES.get(requestFn);
  if (requestHash == null) {
    // Create a new one for the function and put it in the map.
    FN_HASH_COUNTER++;
    requestHash = FN_HASH_COUNTER;
    FN_HASHES.set(requestFn, FN_HASH_COUNTER);
  }

  let refreshHash: number | null = null;
  if (refreshFn) {
    if (FN_HASHES.has(refreshFn)) {
      refreshHash = FN_HASHES.get(refreshFn);
    } else {
      // Create a new one for the function and put it in the map.
      FN_HASH_COUNTER++;
      refreshHash = FN_HASH_COUNTER;
      FN_HASHES.set(refreshFn, FN_HASH_COUNTER);
    }
  }

  return `${requestHash}-${refreshHash}`;
}
