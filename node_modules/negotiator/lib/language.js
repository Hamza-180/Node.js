/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module exports.
 * @public
 */

module.exports = {
  parseAcceptLanguage,
  parseLanguage,
  getLanguagePriority,
  specify,
  preferredLanguages,
  compareSpecs,
  getFullLanguage,
  isQuality,
};

/**
 * Module variables.
 * @private
 */

const simpleLanguageRegExp = /^\s*([^\s;-]+)(?:-([^\s;]*))?(?:;(q=[0-9.]+|;(.*)))?\s*$/;

/**
 * Parse the Accept-Language header.
 * @private
 * @param {string} accept - The Accept-Language header value
 * @returns {Array<Object>} - An array of language specifications
 */
function parseAcceptLanguage(accept) {
  if (typeof accept !== 'string') {
    throw new Error('Expected a string as the first argument');
  }

  const accepts = accept.split(',').map(str => str.trim());
  const parsedAccepts = [];

  for (let i = 0, j = 0; i < accepts.length; i++) {
    const language = parseLanguage(accepts[i], i);

    if (language) {
      parsedAccepts[j++] = language;
    }
  }

  // trim accepts
  parsedAccepts.length = j;

  return parsedAccepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 * @param {string} str - The language string
 * @param {number} i - The index of the language string
 * @returns {Object|null} - A language specification object or null if the string is invalid
 */
function parseLanguage(str, i) {
  const match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  const prefix = match[1];
  const suffix = match[2];
  const full = suffix ? `${prefix}-${suffix}` : prefix;
  let q = 1;

  if (match[3]) {
    const params = match[4].split(';');

    for (let j = 0; j < params.length; j++) {
      const p = params[j].split('=');

      if (p[0] === 'q') {
        q = parseFloat(p[1]);
      }
    }
  }

  return {
    prefix,
    suffix,
    q,
    i,
    full,
  };
}

/**
 * Get the priority of a language.
 * @private
 * @param {string} language - The language string
 * @param {Array<Object>} accepted - An array of accepted language specifications
 * @param {number} index - The index of the language string
 * @returns {Object} - A priority object
 */
function getLanguagePriority(language, accepted, index) {
  const priority = { o: -1, q: 0, s: 0 };

  for (let i = 0; i < accepted.length; i++) {
    const spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 * @param {string} language - The language string
 * @param {Object} spec - A language specification object
 * @param {number} index - The index of the language string
 * @returns {Object|null} - A specificity object or null if the language is not specific enough
 */
function specify(language, spec, index) {
  const p = parseLanguage(language);
  if (!p) return null;

  let s = 0;

  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s,
  };
}

/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 * @param {string} accept - The Accept-Language header value
 * @param {Array<string>} provided - An array of language strings
 * @returns {Array<string>} - An array of preferred language strings
 */
function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  const accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts
      .filter(isQuality
